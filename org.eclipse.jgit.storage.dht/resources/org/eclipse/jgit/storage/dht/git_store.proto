// Copyright (C) 2011, Google Inc.
// and other copyright owners as documented in the project's IP log.
//
// This program and the accompanying materials are made available
// under the terms of the Eclipse Distribution License v1.0 which
// accompanies this distribution, is reproduced below, and is
// available at http://www.eclipse.org/org/documents/edl-v10.php
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or
// without modification, are permitted provided that the following
// conditions are met:
//
// - Redistributions of source code must retain the above copyright
//   notice, this list of conditions and the following disclaimer.
//
// - Redistributions in binary form must reproduce the above
//   copyright notice, this list of conditions and the following
//   disclaimer in the documentation and/or other materials provided
//   with the distribution.
//
// - Neither the name of the Eclipse Foundation, Inc. nor the
//   names of its contributors may be used to endorse or promote
//   products derived from this software without specific prior
//   written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
// CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

package git_store;


    // Describes at a high-level the information about a chunk.
    // A repository can use this summary to determine how much
    // data is stored, or when garbage collection should occur.
    //
message ChunkInfo {
    // Source of the chunk (what code path created it).
    //
  enum Source {
    RECEIVE = 1;    // Came in over the network from external source.
    INSERT = 2;     // Created in this repository (e.g. a merge).
    REPACK = 3;     // Generated during a repack of this repository.
  }
  optional Source source = 1;


    // Type of Git object stored in this chunk.
    //
  enum ObjectType {
    MIXED = 0;
    COMMIT = 1;
    TREE = 2;
    BLOB = 3;
    TAG = 4;
  }
  optional ObjectType object_type = 2;


    // True if this chunk is a member of a fragmented object.
    //
  optional bool is_fragment = 3;

    // Summary description of the objects stored here.
    //
  message ObjectInfo {
      // Number of objects stored in this chunk.
      //
    optional int32 total = 1;

      // Number of objects stored in whole (non-delta) form.
      //
    optional int32 whole = 2;

      // Number of objects stored in OFS_DELTA format.
      // The delta base appears in the same chunk.
      //
    optional int32 ofs_delta = 3;

      // Number of objects stored in REF_DELTA format.
      // The delta base is at an unknown location.
      //
    optional int32 ref_delta = 4;

      // Number of objects stored in CHUNK_DELTA format.
      // The delta base is in another chunk.
      //
    optional int32 chunk_delta = 5;
  }
  optional ObjectInfo objects = 4;


    // Size in bytes of the chunk's compressed data column.
    //
  optional int32 chunk_size = 5;

    // Size in bytes of the chunk's index.
    //
  optional int32 index_size = 6;

    // Size in bytes of the prefetch information.
    //
  optional int32 prefetch_size  = 7;
}


    // Lists all of the chunks that contain a single large object.
    // The fragment field is repeated once for each chunk, and
    // the entire message is attached to every one of those chunks.
    //
message ChunkFragments {
    // Short form of the chunk key for each chunk fragment.
    //
  repeated string fragment = 1;
}


    // Names chunks that should be prefetched if reading the current chunk.
    //
message ChunkPrefetch {
  message Hint {
    repeated string edge = 1;
    repeated string sequential = 2;
  }

  optional Hint commit = 1;
  optional Hint tree = 2;
}


    // Entry in ObjectIndexTable with information
    // about how the object appears in that chunk.
    //
message ObjectInfo {
    // Position of the object's header within its chunk.
    //
  required int32 offset = 1;

    // Total number of compressed data bytes, not including
    // the pack header data.  Objects that are more than 2G
    // in compressed data store 2^31-1 here.
    //
  required int32 packed_size = 2;

    // ObjectId of the delta base, if this object is stored as a delta.
    //
  optional bytes delta_base = 3;

    // True if this object is fragmented across multiple chunks.
    //
  optional bool fragment = 4;
}


    // Entry in RefTable describing the target of the reference.
    // Either symref *OR* target must be populated, but never both.
    //
message RefData {
    // An ObjectId with an optional hint about where it can be found.
    //
  message Id {
    required string object = 1;
    optional string chunk = 2;
  }

    // Name of another reference this reference inherits its target
    // from.  The target is inherited on-the-fly at runtime by reading
    // the other reference.  Typically only "HEAD" uses symref.
    //
  optional string symref = 1;

    // ObjectId this reference currently points at.
    //
  optional Id target = 2;

    // True if the correct value for peeled is stored.
    //
  optional bool is_peeled = 3;

    // If is_peeled is true, this field is accurate.  This field
    // exists only if target points to annotated tag object, then
    // this field stores the "object" field for that tag.
    //
  optional Id peeled = 4;
}


    // Describes a cached ObjectList, for object enumeration.
    //
message ObjectListInfo {
    // Commit this list starts from.
    //
  required string starting_commit = 1;

  message Segment {
      // Chunks within the list where this type starts, and how many it uses.
      //
    required string chunk_start = 1;
    required int32 chunk_count = 2;

      // Number of objects in this segment.
      //
    optional int32 object_count = 3;
  }
  optional Segment commits = 2;
  optional Segment trees = 3;
  optional Segment blobs = 4;

    // Number of chunks that make up this list.
    //
  required int32 chunk_count = 5;

    // Number of objects that are in the list.
    //
  optional int32 object_count = 6;

    // Total size of the list, in bytes.
    //
  optional int32 list_size = 7;
}
